from enum import Enum
from typing import Tuple
import numpy as np


class FaultDomain(Enum):
    """
    ``Enum`` containing all the classes of faulty values.
    """

    ZERO = (0, "zero")
    """
    The golden values is replaced with a 0
    """
    IN_RANGE = (1, "in_range")
    """
    The golden values is replaced with an uniform value between the range of usual values at the output of the layer.
    The range of usual values varies from layer to layer.
    """
    OUT_OF_RANGE = (2, "out_of_range")
    """
    The golden values is replaced with a values outside from the range of usual values at the output of the layer.
    The value is generated by extracting a random bitstring that is reinterpreted as a float value outside of the usual rangte.
    The range of usual values varies from layer to layer.
    """
    NAN = (3, "nan")
    """
    The golden values is replaced with a ``NaN``
    """
    FLIP = (4, "flip")
    """
    A bit of the golden values is flipped.
    """

    def __init__(self, type_id: int, display_name: str):
        self.type_id = type_id
        self.display_name = display_name


class FaultGenerator:

    def __init__(self, range_min: float = -30.0, range_max: float = 30.0):
        self.range_min = range_min
        self.range_max = range_max

    def generate_fault_matrices(self, range: Tuple[float, float] = (-30.0, 30.0)):
        max_pos_float32_uint = 0b01111111011111111111111111111111
        min_neg_float32_uint = 0b11111111011111111111111111111111

        min_float_repr = np.int32(np.randint(min_float_repr))
        max_float_repr = 0
        err_location_matrix = ...  # fault_generator()
        type_matrix = ...
        mask = 1 - err_location_matrix + type_matrix == FaultDomain.IN_RANGE.type_id
        flip = type_matrix == FaultDomain.OUT_OF_RANGE.type_id
        value = val

        # return mask * y +


def generate_out_of_range_values(shape: Tuple[int], range_min, range_max):

    np.random.choice(3, shape, replace=True, p=[range_min])


def uint_repr(x: np.floating) -> np.integer:
    n_bits = x.nbytes << 3
    uint_type = np.dtype(f"uint{n_bits}")
    return x.view(uint_type)


def fill_values(fill_value, size: Tuple[int], dtype=None) -> np.ndarray:
    if dtype is None:
        float_type = fill_value.dtype
    else:
        float_type = dtype
    if fill_value == 0.0:
        return np.zeros(size, dtype=float_type)
    data = np.empty(size, dtype=float_type)
    data[:] = fill_value
    return data


def generate_in_range_values(
    val_range: np.ndarray, size: Tuple[int], dtype=None
) -> np.ndarray:
    """
    Generate a numpy array of floats of the same type of ``val_range`` of size ``size``.
    Each float will be inside of the range specified in ``val_range``.

    Args
    ---
    * ``val_range``: A ``numpy.ndarray`` of shape ``(2,)``. The two values of the array contains the range where the number of the output stand.
    * ``size``: The shape of the output array
    * ``dtype``: Optional data type of the output array. If not specifed the dtype of the output will be the same of ``val_range``

    Returns
    ---
    A ``numpy.ndarray`` of shape ``size`` that contains values in the interval ``[val_range[0], val_range[1]]`` (inside the range).
    """
    assert val_range.shape == (
        2,
    ), f"Last dimension of the range tensor must be {size} but instead is {val_range.shape[-1]}"
    a, b = val_range
    if dtype is None:
        float_type = val_range.dtype
    else:
        float_type = dtype
    return np.random.uniform(a, b, size=size, dtype=float_type)


def generate_out_of_range_values(
    val_range: np.ndarray, size: Tuple[int], dtype=None
) -> np.ndarray:
    """
    Generate a numpy array of floats of the same type of ``val_range`` of size ``size``.
    Each float will be out of the range specified in ``val_range``.

    Args
    ---
    * ``val_range``: A ``numpy.ndarray`` of shape ``(2,)``. The two values of the array contains the range of values to be avoided.
    * ``size``: The shape of the output array
    * ``dtype``: Optional data type of the output array. If not specifed the dtype of the output will be the same of ``val_range``

    Returns
    ---
    A ``numpy.ndarray`` of shape ``size`` that contains only floats less than ``val_range[0]`` or greather than``val_range[1]``
    (outside from the range).
    """
    assert val_range.shape == (
        2,
    ), f"Last dimension of the range tensor must be {size} but instead is {val_range.shape[-1]}"
    if dtype is None:
        float_type = val_range.dtype
    else:
        float_type = dtype

    a, b = val_range
    n_bits = val_range.nbytes << 3
    uint_type = np.dtype(f"uint{n_bits}")

    floats_less_than_a, floats_more_than_a, floats_a_to_zero = (
        get_float_count_from_number(a)
    )
    floats_less_than_b, floats_more_than_b, floats_b_to_zero = (
        get_float_count_from_number(b)
    )
    most_positive_float_ieee754 = np.finfo(float_type).max.view(
        uint_type
    )  # for np.float32 ~ +3*10^38
    most_negative_float_ieee754 = np.finfo(float_type).min.view(
        uint_type
    )  # for np.float32 ~ -3*10^38
    positive_zero_ieee754 = np.uint64(0).astype(uint_type)  # for np.float32  0
    negative_zero_ieee754 = np.uint64(1 << (n_bits - 1)).astype(
        uint_type
    )  # for np.float32  2^32
    floats_with_opposite_sign = np.finfo(float_type).max.view(uint_type)  #

    result = np.zeros(size)

    if float_sign(a) * float_sign(b) < 0:
        # a is negative and b is positive
        #  o----------------------------oxxxxxxxxxxxx0xxxxxxxxxxxxo------------------------o
        #  |    (floats_less_than_a)    |  (range to be avoided)  |  (floats_more_than_b)  |
        # -inf                          a            0            b                      +inf
        smaller_than_a = floats_less_than_a
        bigger_than_b = floats_more_than_b
        range_sides_probs = np.array(
            [smaller_than_a, bigger_than_b], type=uint_type
        ) / (smaller_than_a + bigger_than_b)
        small_big_choices = np.random.choice(
            [False, True], size, replace=True, p=range_sides_probs
        )
        bigger_than_b_count = small_big_choices.sum()
        smaller_than_a_count = small_big_choices.size - bigger_than_b_count

        smaller_than_a_values = np.random.randint(
            uint_repr(a),
            most_negative_float_ieee754,
            size=(smaller_than_a_count,),
            dtype=uint_type,
        ).view(float_type)
        bigger_than_b_values = np.random.randint(
            uint_repr(b),
            most_positive_float_ieee754,
            size=(bigger_than_b_count,),
            dtype=uint_type,
        ).view(float_type)

        result[small_big_choices] = smaller_than_a_values
        result[~small_big_choices] = bigger_than_b_values
    elif float_sign(a) < 0:
        # a and b are both negative
        #  o----------------------------oxxxxxxxxxxxxxxxxxxxxxxxxxo----------------------o---------------------------------o
        #  |     (floats_less_than_a)   |  (range to be avoided)  |  (floats_b_to_zero)  |   (floats_with_opposite_sign)   |
        # -inf                          a                         b                      0                                +inf
        smaller_than_a = floats_less_than_a
        bigger_than_b = floats_b_to_zero + floats_with_opposite_sign
        # First choose if each value stands in (-inf,a) or (b,+inf)
        range_sides_probs = np.array(
            [smaller_than_a, bigger_than_b], type=uint_type
        ) / (smaller_than_a + bigger_than_b)
        range_sides_choices = np.random.choice(
            [False, True], size, replace=True, p=range_sides_probs
        )
        # Then choose, for the values between
        sign_probs = (
            np.array([floats_b_to_zero, floats_with_opposite_sign], type=uint_type)
            / bigger_than_b
        )
        sign_choices = np.random.choice([False, True], size, replace=True, p=sign_probs)
        floats_with_opposite_sign_choices = range_sides_choices & sign_choices
        floats_b_to_zero_choices = range_sides_choices & ~sign_choices
        floats_less_than_a_choices = ~range_sides_choices

        floats_with_opposite_sign_values = np.random.randint(
            positive_zero_ieee754,
            most_positive_float_ieee754,
            size=(floats_with_opposite_sign_choices.sum(),),
            dtype=uint_type,
        ).view(float_type)
        floats_b_to_zero_values = np.random.randint(
            uint_repr(b),
            negative_zero_ieee754,
            size=(floats_b_to_zero_choices.sum(),),
            dtype=uint_type,
        ).view(float_type)
        floats_less_than_a_values = np.random.randint(
            most_negative_float_ieee754,
            uint_repr(a),
            size=(floats_less_than_a_choices.sum(),),
            dtype=uint_type,
        ).view(float_type)

        result[floats_with_opposite_sign_choices] = floats_with_opposite_sign_values
        result[floats_b_to_zero_choices] = floats_b_to_zero_values
        result[floats_less_than_a_choices] = floats_less_than_a_values
    else:
        # a and b are both positive
        #  o--------------------------------o-----------------------oxxxxxxxxxxxxxxxxxxxxxxxxo--------------------------o
        #  |  (floats_with_opposite_sign)   |  (floats_a_to_zero)  |  (range to be avoided)  |   (floats_more_than_b)   |
        # -inf                              0                      a                         b                        +inf
        smaller_than_a = floats_with_opposite_sign + floats_a_to_zero
        bigger_than_b = floats_more_than_b
        # First choose if each value stands in (-inf,a) or (b,+inf)
        range_sides_probs = np.array(
            [smaller_than_a, bigger_than_b], type=uint_type
        ) / (smaller_than_a + bigger_than_b)
        range_sides_choices = np.random.choice(
            [False, True], size, replace=True, p=range_sides_probs
        )
        # Then choose, for the values between
        sign_probs = (
            np.array([floats_with_opposite_sign, floats_a_to_zero], type=uint_type)
            / smaller_than_a
        )
        sign_choices = np.random.choice([False, True], size, replace=True, p=sign_probs)
        floats_with_opposite_sign_choices = ~range_sides_choices & ~sign_choices
        floats_a_to_zero_choices = ~range_sides_choices & sign_choices
        floats_more_than_b_choices = range_sides_choices

        floats_with_opposite_sign_values = np.random.randint(
            most_negative_float_ieee754,
            negative_zero_ieee754,
            size=(floats_with_opposite_sign_choices.sum(),),
            dtype=uint_type,
        ).view(float_type)
        floats_a_to_zero_values = np.random.randint(
            negative_zero_ieee754,
            uint_repr(a),
            size=(floats_a_to_zero_choices.sum(),),
            dtype=uint_type,
        ).view(float_type)
        floats_more_than_b_values = np.random.randint(
            uint_repr(b),
            most_positive_float_ieee754,
            size=(floats_more_than_b_choices.sum(),),
            dtype=uint_type,
        ).view(float_type)

        result[floats_with_opposite_sign_choices] = floats_with_opposite_sign_values
        result[floats_a_to_zero_choices] = floats_a_to_zero_values
        result[floats_more_than_b_choices] = floats_more_than_b_values

    return result


def float_sign(x: np.floating) -> np.int8:
    assert isinstance(
        x, np.floating
    ), f"input must be a numpy floating but is {type(x)}"
    n_bits = x.nbytes << 3
    target_type = np.dtype(f"uint{n_bits}")
    negative_zero_ieee754 = np.uint64(1 << (n_bits - 1)).astype(target_type)
    x_as_uint = x.view(np.uint32)
    return np.int8(+1 if x_as_uint < negative_zero_ieee754 else -1)


def get_float_count_from_number(x: np.floating) -> Tuple[int, int, int]:
    assert isinstance(
        x, np.floating
    ), f"input must be a numpy floating but is {type(x)}"
    n_bits = x.nbytes << 3
    uint_type = np.dtype(f"uint{n_bits}")
    floats_with_opposite_sign = np.finfo(x).max.view(uint_type)
    positive_zero_ieee754 = np.uint64(0).astype(uint_type)
    negative_zero_ieee754 = np.uint64(1 << (n_bits - 1)).astype(uint_type)
    most_positive_float_ieee754 = np.finfo(x).max.view(uint_type)
    most_negative_float_ieee754 = np.finfo(x).min.view(uint_type)

    x_as_uint = np.array(x, dtype=np.float32).view(np.uint32)
    if float_sign(x) >= 0:
        floats_from_pos_zero = x_as_uint - positive_zero_ieee754
        floats_to_max_float = most_positive_float_ieee754 - x_as_uint
        floats_less_than_x = floats_with_opposite_sign + floats_from_pos_zero
        floats_more_than_x = floats_to_max_float
        return floats_less_than_x, floats_more_than_x, floats_from_pos_zero
    else:
        floats_from_neg_zero = x_as_uint - negative_zero_ieee754
        # print(f'{floats_from_neg_zero=}')
        floats_to_min_float = most_negative_float_ieee754 - x_as_uint
        # print(f'{floats_to_min_float=}')
        floats_less_than_x = floats_to_min_float
        # print(f'{floats_less_than_x=}')
        floats_more_than_x = floats_from_neg_zero + floats_with_opposite_sign
        # print(f'{floats_more_than_x=}')
        return floats_less_than_x, floats_more_than_x, floats_from_neg_zero


print(get_float_count_from_number(-1e10))
